# Java 2 实用教程 习题4

[TOC]

## 1. 问答题

### （1）面向对象语言有哪三个特性？

封装、继承、多态。

### （2）类名应当遵守怎样的编程风格？

类名通常采用帕斯卡命名法（Pascal Case）：首字母大写、每个单词的首字母大写。例如：Hello、Time、MyPoint等。

### （3）变量和方法的名字应当遵守怎样的编程风格？

驼峰命名法（Camel Case）：首字母小写，第二个及以后的单词大写。例如：userName。

### （4）类体内容中声明成员变量是为了体现对象的属性还是行为？

属性。

### （5）类体内容中定义的非构造方法是为了体现对象的属性还是行为？

行为。

### （6）什么时候使用构造方法？构造方法有类型吗？

构造方法在类的对象被创建时调用。构造方法没有类型。

### （7）类中的实例变量在什么时候会被分配内存空间？

在 new 运算符调用类的构造方法时。准确地说，在构造方法被执行之前，类的实例变量被分配内存空间。

### （8）什么叫方法的重载？构造方法可以重载吗？

方法重载：两个方法拥有相同的名字，但有着不同的参数表（即：参数的个数不同，或者参数的类型不同）。构造方法也可以重载。

### （9）类中的实例方法可以操作类变量（static 变量）吗？类方法（static 方法）可以操作实例变量吗？

实例方法可以操作 static 变量，但 static 方法无法操作实例变量。因为 static 变量独立于所有对象，在任何对象创建前就已存在。static 方法可以通过对象调用，也可以通过类名调用，而 static 方法被调用时，对象可能还不存在。

### （10）类中的实例方法可以用类名直接调用吗？

不可以。类的实例方法需要通过对象名调用，以给出具体作用的对象。

### （11）简述类变量和实例变量的区别。

static 变量独立于所有对象，在任何对象创建前就已存在，由类的所有成员所共有。而实例变量依附于类的实例对象而存在，与对象一起创建和回收，不同的对象各自拥有自己的实例变量。

### （12）this 关键字代表什么？this可以出现在类方法中吗？

this 关键字指代当前对象，通常在方法的局部变量与类的实例变量重名时，此时类的实例变量被隐藏，便可通过this关键字来调用。例如：

```java
class A {
    int x;
    void setX(int x) {
        this.x = x;
    }
}
```

方法 setX 中，this 关键字被用于区分这两种变量。

由于第9题同样的原因（static方法不依赖于任何对象，无法操作实例变量；static 方法被调用时，对象可能还不存在），static 方法被调用时，可能并不存在这样一个 this（调用 static 方法的对象）。

## 2. 选择题

### （1）下列哪个叙述是正确的？

> （1）下列哪个叙述是正确的？
>
> A. Java 应用程序由若干个类所构成，这些类必须在一个源文件中。
>
> B. Java 应用程序由若干个类所构成，这些类可以在一个源文件中，也可以分布在若干个源文件中，其中必须有一个源文件含有主类。
>
> C. Java 源文件必须含有主类。
>
> D. Java 源文件如果含有主类，主类必须是 public 类。

答案：B。

Java 应用程序由若干个类所构成，这些类可以在一个源文件中，也可以分布在若干个源文件中，其中必须有一个源文件含有主类。 Java 源文件含有的主类不一定是 public 类。一个 Java 源文件至多含有一个 public 类，且类名必须与文件名相同。

### （2）下列哪个叙述是正确的？

> （2）下列哪个叙述是正确的？
>
> A. 成员变量的名字不可以和局部变量的名字相同。
>
> B. 方法的参数的名字可以和方法中声明的局部变量的名字相同。
>
> C. 成员变量没有默认值。
>
> D. 局部变量没有默认值。

答案：D。

成员变量的名字可以和局部变量的名字相同，此时，同名的成员变量会被覆盖，可以用 this 关键字加以区分。方法的参数的名字被视为局部变量，不能与方法中声明的局部变量的名字相同。成员变量具有零或空的默认值：对于数据类型变量，这个值是0；对于布尔类型是false；对于引用类型（包括字符串）是null。局部变量没有默认值，如果直接使用局部变量，会产生编译错误。

### （3）对于下列 Hello 类，哪个叙述是正确的？

> （3）对于下列 Hello 类，哪个叙述是正确的?
>
> A. Hello 类有两个构造方法。
>
> B. Hello 类的 `int Hello()` 方法是错误的方法。
>
> C. Hello 类没有构造方法。
>
> D. Hello 无法通过编译，因为其中的 hello 方法的方法头是错误的（没有类型）。
>
> ```java
> class Hello {
>     Hello(int m) {}
>     int Hello() {
>         return 20;
>     }
>     hello() {}
> }
> ```

答案：D。

hello 作为非构造方法的普通成员方法，必须具有返回值。

### （4）对于下列 Dog 类，哪个叙述是错误的？

> （4）对于下列 Dog 类，哪个叙述是错误的？
>
> A. `Dog(int m)` 与 `Dog(double m)` 是互为重载的构造方法
>
> B. `int Dog(int m)` 与 `void Dog(double m)` 是互为重载的非构造方法
>
> C. Dog 类只有两个构造方法，而且没有无参数的构造方法
>
> D. Dog类有三个构造方法
>
> ```java
> class Dog {
>     Dog(int m) {}
>     Dog(double m) {}
>     int Dog(int m) {
>         return 23;
>     }
>     void Dog(double m) {}
> }
> ```

答案：D。

前两个函数是互为重载的构造方法，后两个函数是互为重载的非构造方法。

### （5）下列哪些类声明是错误的？

> （5）下列哪些类声明是错误的？
>
> A. class A
>
> B. public class A
>
> C. protected class A
>
> D. private class A

答案：CD。

类的声明修饰符只能为默认（包可访问）的或者 public 的。

### （6）下列 A 类中【代码1】~【代码5】哪些是错误的？

```java
class Tom {
    private int x = 120;
    protected int y = 20;
    int z = 11;
    private void f() {
        x = 200;
        System.out.println(x);
    }
    void g() {
        x = 200;
        System.out.println(x);
    }
}
public class A {
    public static void main(String args[]) {
        Tom tom = new Tom();
        tom.x = 22;		// 【代码1】
        tom.y = 33;		// 【代码2】
        tom.z = 55;		// 【代码3】
        tom.f();		// 【代码4】
        tom.g();		// 【代码5】
    }
}
```

【代码 1】、【代码 4】是错误的：不能访问被 private 修饰符修饰的成员。而 protected 修饰的默认同一包中的类是可以访问的。

### （7）下列 E 类的类体中哪些【代码】是错误的？

> （7）下列 E 类的类体中哪些【代码】是错误的？
>
> ```java
> class E {
>     int x;				// 【代码1】
>     long y = x;			// 【代码2】
>     public void f(int n) {
>         int m;			// 【代码3】
>         int t = n+m;	// 【代码4】
>     }
> }
> ```

【代码 4】是错误的：使用了未经初始化的变量 m。